Project Path: ocean_plugin

Source Tree:

```txt
ocean_plugin
├── ModuleAttribute.cs
├── MultiAttributeFusion.cs
├── PercentileClipNormalization.cs
├── Plugin.cs
├── Properties
│   └── AssemblyInfo.cs
├── StructureTensor.cs
├── ocean_plugin.csproj
├── ocean_plugin.sln
├── plugin.xml
└── prompt.txt

```

`ocean_plugin/MultiAttributeFusion.cs`:

```cs
using System;
using System.Collections.Generic;

using Slb.Ocean.Core;
using Slb.Ocean.Basics;
using Slb.Ocean.Petrel;
using Slb.Ocean.Petrel.Data;
using Slb.Ocean.Petrel.Data.Persistence;
using Slb.Ocean.Petrel.DomainObject;
using Slb.Ocean.Petrel.Seismic;
using Slb.Ocean.Petrel.DomainObject.Seismic;
using Slb.Ocean.Petrel.Workflow;
using Slb.Ocean.Petrel.UI;
using Slb.Ocean.Petrel.UI.Controls; // 需要为 [Description] 注解引入

namespace ocean_plugin
{
    class MultiAttributeFusion : SeismicAttribute<MultiAttributeFusion.Arguments>, IDescriptionSource
    {
        #region Overrides from SeismicAttribute

        protected override Arguments CreateArgumentPackageCore(IDataSourceManager manager)
        {
            Arguments argPack = new Arguments();
            StructuredArchiveDataSource dataSource = manager.GetSource(ArgumentPackageDataSourceFactory.DataSourceId) as StructuredArchiveDataSource;
            if (dataSource != null)
            {
                argPack.Droid = dataSource.GenerateDroid();
                dataSource.AddItem(argPack.Droid, argPack);
            }
            return argPack;
        }

        public override void CopyArgumentPackage(MultiAttributeFusion.Arguments fromArgumentPackage, MultiAttributeFusion.Arguments toArgumentPackage)
        {
            if (fromArgumentPackage != null && toArgumentPackage != null)
            {
                toArgumentPackage.CopyFrom(fromArgumentPackage);
            }
        }

        public override bool CompareArgumentPackage(MultiAttributeFusion.Arguments firstArgumentPackage, MultiAttributeFusion.Arguments secondArgumentPackage)
        {
            if (firstArgumentPackage != null && secondArgumentPackage != null)
            {
                return firstArgumentPackage.EqualsTo(secondArgumentPackage);
            }
            return false;
        }

        public override SeismicAttributeGenerator CreateAttributeGenerator(MultiAttributeFusion.Arguments argumentPackage, IGeneratorContext context)
        {
            return new MultiAttributeFusion.Generator(argumentPackage, context);
        }

        // ====================================================================================
        // 关键修改 1: 实现参数验证逻辑
        // ====================================================================================
        public override bool Validate(MultiAttributeFusion.Arguments args, IGeneratorContext context, out string errorMessage)
        {
            if (args.MinThreshold1 > args.MaxThreshold1) { errorMessage = "Input 1: Min Threshold cannot be greater than Max Threshold."; return false; }
            if (args.MinThreshold2 > args.MaxThreshold2) { errorMessage = "Input 2: Min Threshold cannot be greater than Max Threshold."; return false; }
            if (args.MinThreshold3 > args.MaxThreshold3) { errorMessage = "Input 3: Min Threshold cannot be greater than Max Threshold."; return false; }
            if (args.MinThreshold4 > args.MaxThreshold4) { errorMessage = "Input 4: Min Threshold cannot be greater than Max Threshold."; return false; }
            if (args.MinThreshold5 > args.MaxThreshold5) { errorMessage = "Input 5: Min Threshold cannot be greater than Max Threshold."; return false; }
            if (args.MinThreshold6 > args.MaxThreshold6) { errorMessage = "Input 6: Min Threshold cannot be greater than Max Threshold."; return false; }

            errorMessage = "N/A";
            return true;
        }

        public override SeismicAttributeInfo CreateSeismicAttributeInfo(MultiAttributeFusion.Arguments argumentPackage, IGeneratorContext context)
        {
            // 使用默认模板和自动范围，更适合融合结果
            IList<Slb.Ocean.Petrel.DomainObject.Template> templates = new List<Slb.Ocean.Petrel.DomainObject.Template> { PetrelProject.WellKnownTemplates.SeismicColorGroup.SeismicDefault };
            IList<Range1<float>> ranges = new List<Range1<float>>(); // 空列表表示自动计算范围
            return new SeismicAttributeInfo(templates, ranges, new Index3(1, 1, 1), BorderProcessingMethod.Repeat);
        }

        public override string CategoryName
        {
            get { return WellKnownAttributeCategory.Basic; }
        }

        public override int InputCount
        {
            get { return 6; }
        }

        public override int OutputCount
        {
            get { return 1; }
        }

        protected override IEnumerable<string> GetInputLabels(MultiAttributeFusion.Arguments argumentPackage, IGeneratorContext context)
        {
            yield return "RMS Amplitude";
            yield return "RMS Frequency";
            yield return "Envelope";
            yield return "Sweetness";
            yield return "Amplitude Gradient";
            yield return "Structural Tensor";
        }

        protected override IEnumerable<string> GetOutputLabels(MultiAttributeFusion.Arguments argumentPackage, IGeneratorContext context)
        {
            yield return "Fusion Result";
        }

        #endregion

        #region Attribute Description related members
        public IDescription Description
        {
            get { return new AttributeDescription(); }
        }

        private class AttributeDescription : IDescription
        {
            public string Name
            {
                get { return "Thresholded Attribute Fusion"; }
            }
            public string Description
            {
                get { return "Conditionally blends multiple attributes using weights and thresholds. Output = Sum(w_i * (InRange(v_i) ? v_i : 0))"; }
            }
            public string ShortDescription
            {
                get { return "Weighted fusion with thresholds."; }
            }
        }
        #endregion

        // ====================================================================================
        // 关键修改 2: 填充 Arguments 类，为每个输入定义三个参数
        // ====================================================================================
        [Archivable(FromRelease = "2020.1")]
        public class Arguments : Slb.Ocean.Petrel.Workflow.DescribedArgumentsByReflection, IIdentifiable, IDisposable, Slb.Ocean.Petrel.Seismic.INotifyingOnChanged
        {
            #region Parameters
            // --- Input 1 Parameters ---
            private double weight1 = 1.0;
            private double minThreshold1 = 0.0;
            private double maxThreshold1 = 1.0;

            [Archived(Name = "Weight1"), Description("Weight (Input 1)", "Weight for the first attribute.")]
            public double Weight1 { get { return weight1; } set { weight1 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold1"), Description("Min Threshold (Input 1)", "Minimum value threshold for the first attribute.")]
            public double MinThreshold1 { get { return minThreshold1; } set { minThreshold1 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold1"), Description("Max Threshold (Input 1)", "Maximum value threshold for the first attribute.")]
            public double MaxThreshold1 { get { return maxThreshold1; } set { maxThreshold1 = value; OnChanged(); } }

            // --- Input 2 Parameters ---
            private double weight2 = 0.0;
            private double minThreshold2 = 0.0;
            private double maxThreshold2 = 1.0;

            [Archived(Name = "Weight2"), Description("Weight (Input 2)", "Weight for the second attribute.")]
            public double Weight2 { get { return weight2; } set { weight2 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold2"), Description("Min Threshold (Input 2)", "Minimum value threshold for the second attribute.")]
            public double MinThreshold2 { get { return minThreshold2; } set { minThreshold2 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold2"), Description("Max Threshold (Input 2)", "Maximum value threshold for the second attribute.")]
            public double MaxThreshold2 { get { return maxThreshold2; } set { maxThreshold2 = value; OnChanged(); } }

            // --- Input 3 Parameters ---
            private double weight3 = 0.0;
            private double minThreshold3 = 0.0;
            private double maxThreshold3 = 1.0;

            [Archived(Name = "Weight3"), Description("Weight (Input 3)", "Weight for the third attribute.")]
            public double Weight3 { get { return weight3; } set { weight3 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold3"), Description("Min Threshold (Input 3)", "Minimum value threshold for the third attribute.")]
            public double MinThreshold3 { get { return minThreshold3; } set { minThreshold3 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold3"), Description("Max Threshold (Input 3)", "Maximum value threshold for the third attribute.")]
            public double MaxThreshold3 { get { return maxThreshold3; } set { maxThreshold3 = value; OnChanged(); } }

            // --- Input 4 Parameters ---
            private double weight4 = 0.0;
            private double minThreshold4 = 0.0;
            private double maxThreshold4 = 1.0;

            [Archived(Name = "Weight4"), Description("Weight (Input 4)", "Weight for the fourth attribute.")]
            public double Weight4 { get { return weight4; } set { weight4 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold4"), Description("Min Threshold (Input 4)", "Minimum value threshold for the fourth attribute.")]
            public double MinThreshold4 { get { return minThreshold4; } set { minThreshold4 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold4"), Description("Max Threshold (Input 4)", "Maximum value threshold for the fourth attribute.")]
            public double MaxThreshold4 { get { return maxThreshold4; } set { maxThreshold4 = value; OnChanged(); } }

            // --- Input 5 Parameters ---
            private double weight5 = 0.0;
            private double minThreshold5 = 0.0;
            private double maxThreshold5 = 1.0;

            [Archived(Name = "Weight5"), Description("Weight (Input 5)", "Weight for the fifth attribute.")]
            public double Weight5 { get { return weight5; } set { weight5 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold5"), Description("Min Threshold (Input 5)", "Minimum value threshold for the fifth attribute.")]
            public double MinThreshold5 { get { return minThreshold5; } set { minThreshold5 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold5"), Description("Max Threshold (Input 5)", "Maximum value threshold for the fifth attribute.")]
            public double MaxThreshold5 { get { return maxThreshold5; } set { maxThreshold5 = value; OnChanged(); } }

            // --- Input 6 Parameters ---
            private double weight6 = 0.0;
            private double minThreshold6 = 0.0;
            private double maxThreshold6 = 1.0;

            [Archived(Name = "Weight6"), Description("Weight (Input 6)", "Weight for the sixth attribute.")]
            public double Weight6 { get { return weight6; } set { weight6 = value; OnChanged(); } }
            [Archived(Name = "MinThreshold6"), Description("Min Threshold (Input 6)", "Minimum value threshold for the sixth attribute.")]
            public double MinThreshold6 { get { return minThreshold6; } set { minThreshold6 = value; OnChanged(); } }
            [Archived(Name = "MaxThreshold6"), Description("Max Threshold (Input 6)", "Maximum value threshold for the sixth attribute.")]
            public double MaxThreshold6 { get { return maxThreshold6; } set { maxThreshold6 = value; OnChanged(); } }
            #endregion

            #region Boilerplate Methods
            public Arguments() { }

            [Archived(Name = "Droid")] private Droid droid;
            public Droid Droid { get { return droid; } set { droid = value; } }

            // ====================================================================================
            // 关键修改 3: 实现参数的复制和比较方法
            // ====================================================================================
            public void CopyFrom(Arguments another)
            {
                if (another == null) return;
                this.Weight1 = another.Weight1; this.MinThreshold1 = another.MinThreshold1; this.MaxThreshold1 = another.MaxThreshold1;
                this.Weight2 = another.Weight2; this.MinThreshold2 = another.MinThreshold2; this.MaxThreshold2 = another.MaxThreshold2;
                this.Weight3 = another.Weight3; this.MinThreshold3 = another.MinThreshold3; this.MaxThreshold3 = another.MaxThreshold3;
                this.Weight4 = another.Weight4; this.MinThreshold4 = another.MinThreshold4; this.MaxThreshold4 = another.MaxThreshold4;
                this.Weight5 = another.Weight5; this.MinThreshold5 = another.MinThreshold5; this.MaxThreshold5 = another.MaxThreshold5;
                this.Weight6 = another.Weight6; this.MinThreshold6 = another.MinThreshold6; this.MaxThreshold6 = another.MaxThreshold6;
            }

            public bool EqualsTo(Arguments another)
            {
                if (another == null) return false;
                return this.Weight1.Equals(another.Weight1) && this.MinThreshold1.Equals(another.MinThreshold1) && this.MaxThreshold1.Equals(another.MaxThreshold1) &&
                       this.Weight2.Equals(another.Weight2) && this.MinThreshold2.Equals(another.MinThreshold2) && this.MaxThreshold2.Equals(another.MaxThreshold2) &&
                       this.Weight3.Equals(another.Weight3) && this.MinThreshold3.Equals(another.MinThreshold3) && this.MaxThreshold3.Equals(another.MaxThreshold3) &&
                       this.Weight4.Equals(another.Weight4) && this.MinThreshold4.Equals(another.MinThreshold4) && this.MaxThreshold4.Equals(another.MaxThreshold4) &&
                       this.Weight5.Equals(another.Weight5) && this.MinThreshold5.Equals(another.MinThreshold5) && this.MaxThreshold5.Equals(another.MaxThreshold5) &&
                       this.Weight6.Equals(another.Weight6) && this.MinThreshold6.Equals(another.MinThreshold6) && this.MaxThreshold6.Equals(another.MaxThreshold6);
            }

            public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
            protected virtual void Dispose(bool disposing) { }

            public event EventHandler<ArgumentPackageChangedEventArgs> Changed;
            private void OnChanged()
            {
                if (Changed != null)
                    Changed(this, new ArgumentPackageChangedEventArgs());
            }
            #endregion
        }

        public class ArgumentPackageDataSourceFactory : DataSourceFactory
        {
            public static string DataSourceId = @"fd0d0a73-9acc-4e0a-ba31-82d1426c340e";
            public override IDataSource GetDataSource()
            {
                return new StructuredArchiveDataSource(DataSourceId, new[] { typeof(Arguments) });
            }
        }

        public class Generator : SeismicAttributeGenerator
        {
            private MultiAttributeFusion.Arguments arguments;
            private IGeneratorContext generatorContext;

            public Generator(MultiAttributeFusion.Arguments arguments, IGeneratorContext generatorContext)
            {
                this.arguments = arguments;
                this.generatorContext = generatorContext;
            }

            #region Overrides from SeismicAttributeGenerator
            public override void Initialize()
            {
                // 无需预计算，保持为空
            }

            // ====================================================================================
            // 关键修改 4: 实现融合算法的核心
            // ====================================================================================
            public override void Calculate(ISubCube[] input, ISubCube[] output)
            {
                ISubCube outCube = output[0];

                // 提前将参数转换为float，避免在内层循环中反复转换
                float w1 = (float)arguments.Weight1, min1 = (float)arguments.MinThreshold1, max1 = (float)arguments.MaxThreshold1;
                float w2 = (float)arguments.Weight2, min2 = (float)arguments.MinThreshold2, max2 = (float)arguments.MaxThreshold2;
                float w3 = (float)arguments.Weight3, min3 = (float)arguments.MinThreshold3, max3 = (float)arguments.MaxThreshold3;
                float w4 = (float)arguments.Weight4, min4 = (float)arguments.MinThreshold4, max4 = (float)arguments.MaxThreshold4;
                float w5 = (float)arguments.Weight5, min5 = (float)arguments.MinThreshold5, max5 = (float)arguments.MaxThreshold5;
                float w6 = (float)arguments.Weight6, min6 = (float)arguments.MinThreshold6, max6 = (float)arguments.MaxThreshold6;

                Index3 min = outCube.MinIJK;
                Index3 max = outCube.MaxIJK;

                for (int k = min.K; k <= max.K; k++)
                {
                    for (int j = min.J; j <= max.J; j++)
                    {
                        for (int i = min.I; i <= max.I; i++)
                        {
                            Index3 idx = new Index3(i, j, k);
                            float finalValue = 0.0f;
                            float currentVal;

                            // 处理每个输入
                            // 如果输入槽为空，Petrel传入的input[i]会是null
                            // 我们需要检查null，避免程序崩溃

                            if (input[0] != null)
                            {
                                currentVal = input[0][idx];
                                if (currentVal >= min1 && currentVal <= max1)
                                    finalValue += currentVal * w1;
                            }
                            if (input[1] != null)
                            {
                                currentVal = input[1][idx];
                                if (currentVal >= min2 && currentVal <= max2)
                                    finalValue += currentVal * w2;
                            }
                            if (input[2] != null)
                            {
                                currentVal = input[2][idx];
                                if (currentVal >= min3 && currentVal <= max3)
                                    finalValue += currentVal * w3;
                            }
                            if (input[3] != null)
                            {
                                currentVal = input[3][idx];
                                if (currentVal >= min4 && currentVal <= max4)
                                    finalValue += currentVal * w4;
                            }
                            if (input[4] != null)
                            {
                                currentVal = input[4][idx];
                                if (currentVal >= min5 && currentVal <= max5)
                                    finalValue += currentVal * w5;
                            }
                            if (input[5] != null)
                            {
                                currentVal = input[5][idx];
                                if (currentVal >= min6 && currentVal <= max6)
                                    finalValue += currentVal * w6;
                            }

                            outCube[idx] = finalValue;
                        }
                    }
                }
            }
            #endregion
        }
    }
}
```

`ocean_plugin/PercentileClipNormalization.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;

using Slb.Ocean.Core;
using Slb.Ocean.Basics;
using Slb.Ocean.Petrel;
using Slb.Ocean.Petrel.Data;
using Slb.Ocean.Petrel.Data.Persistence;
using Slb.Ocean.Petrel.DomainObject;
using Slb.Ocean.Petrel.Seismic;
using Slb.Ocean.Petrel.DomainObject.Seismic;
using Slb.Ocean.Petrel.Workflow;
using Slb.Ocean.Petrel.UI;
using Slb.Ocean.Petrel.UI.Controls; // 需要为 [Description] 注解引入

namespace ocean_plugin
{
    class PercentileClipNormalization : SeismicAttribute<PercentileClipNormalization.Arguments>, IDescriptionSource
    {
        #region Boilerplate Code (无需修改)
        protected override Arguments CreateArgumentPackageCore(IDataSourceManager manager)
        {
            Arguments argPack = new Arguments();
            StructuredArchiveDataSource dataSource = manager.GetSource(ArgumentPackageDataSourceFactory.DataSourceId) as StructuredArchiveDataSource;
            if (dataSource != null)
            {
                argPack.Droid = dataSource.GenerateDroid(); dataSource.AddItem(argPack.Droid, argPack);
            }
            return argPack;
        }
        public override void CopyArgumentPackage(PercentileClipNormalization.Arguments fromArgumentPackage, PercentileClipNormalization.Arguments toArgumentPackage)
        {
            if (fromArgumentPackage != null && toArgumentPackage != null)
            {
                toArgumentPackage.CopyFrom(fromArgumentPackage);
            }
        }
        public override bool CompareArgumentPackage(PercentileClipNormalization.Arguments firstArgumentPackage, PercentileClipNormalization.Arguments secondArgumentPackage)
        {
            if (firstArgumentPackage != null && secondArgumentPackage != null)
            {
                return firstArgumentPackage.EqualsTo(secondArgumentPackage);
            }
            return false;
        }
        public override SeismicAttributeGenerator CreateAttributeGenerator(PercentileClipNormalization.Arguments argumentPackage, IGeneratorContext context)
        {
            return new PercentileClipNormalization.Generator(argumentPackage, context);
        }
        // *********************************************************************************
        // 关键修改 1: 更新 Validate 方法以检查新参数的逻辑有效性
        // *********************************************************************************
        public override bool Validate(PercentileClipNormalization.Arguments argumentPackage, IGeneratorContext context, out string errorMessage)
        {
            if (argumentPackage.LowerPercentile >= argumentPackage.UpperPercentile)
            {
                errorMessage = "Lower Percentile must be less than Upper Percentile.";
                return false;
            }
            errorMessage = "N/A";
            return true;
        }
        public override SeismicAttributeInfo CreateSeismicAttributeInfo(PercentileClipNormalization.Arguments argumentPackage, IGeneratorContext context)
        {
            IList<Template> templates = new List<Template>();
            IList<Range1<float>> ranges = new List<Range1<float>>();
            templates.Add(PetrelProject.WellKnownTemplates.SeismicColorGroup.SeismicVariance);
            ranges.Add(new Range1<float>(0f, 1f));
            return new SeismicAttributeInfo(templates, ranges, new Index3(1, 1, 1), BorderProcessingMethod.Repeat);
        }
        public override string CategoryName
        {
            get
            {
                return WellKnownAttributeCategory.Basic;
            }
        }
        public override int InputCount { get { return 1; } }
        public override int OutputCount { get { return 1; } }
        protected override IEnumerable<string> GetInputLabels(PercentileClipNormalization.Arguments argumentPackage, IGeneratorContext context) { yield return "Input"; }
        protected override IEnumerable<string> GetOutputLabels(PercentileClipNormalization.Arguments argumentPackage, IGeneratorContext context) { yield return "Output"; }
        #endregion

        #region Attribute Description & Arguments
        public IDescription Description { get { return new AttributeDescription(); } }
        private class AttributeDescription : IDescription
        {
            public string Name { get { return "Percentile clip normalization"; } }
            // 更新描述以反映其参数化特性
            public string Description { get { return "Clips data at user-defined percentiles to suppress outliers, then scales the result to a [0, 1] range to enhance contrast. Memory-efficient implementation."; } }
            public string ShortDescription { get { return "Clips at percentiles and scales to 0-1."; } }
        }

        [Archivable(FromRelease = "2020.1")]
        public class Arguments : Slb.Ocean.Petrel.Workflow.DescribedArgumentsByReflection, IIdentifiable, IDisposable, Slb.Ocean.Petrel.Seismic.INotifyingOnChanged
        {
            // *********************************************************************************
            // 关键修改 2: 在 Arguments 类中定义用户可输入的参数
            // *********************************************************************************
            private double lowerPercentile = 1.0;
            private double upperPercentile = 99.0;

            [Archived(Name = "LowerPercentile")]
            [Description("Lower Percentile (%)", "The lower percentile boundary for clipping (e.g., 1). Values below this will be set to this boundary.")]
            public double LowerPercentile
            {
                get { return lowerPercentile; }
                set
                {
                    lowerPercentile = value;
                    OnChanged(); // 通知Petrel参数已改变
                }
            }

            [Archived(Name = "UpperPercentile")]
            [Description("Upper Percentile (%)", "The upper percentile boundary for clipping (e.g., 99). Values above this will be set to this boundary.")]
            public double UpperPercentile
            {
                get { return upperPercentile; }
                set
                {
                    upperPercentile = value;
                    OnChanged(); // 通知Petrel参数已改变
                }
            }

            public Arguments() { }
            [Archived(Name = "Droid")] private Droid droid;
            public Droid Droid { get { return droid; } set { droid = value; } }

            // 必须更新 CopyFrom 和 EqualsTo 以包含新参数
            public void CopyFrom(Arguments another)
            {
                if (another != null)
                {
                    this.LowerPercentile = another.LowerPercentile;
                    this.UpperPercentile = another.UpperPercentile;
                }
            }
            public bool EqualsTo(Arguments another)
            {
                return another != null &&
                       this.LowerPercentile.Equals(another.LowerPercentile) &&
                       this.UpperPercentile.Equals(another.UpperPercentile);
            }

            public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
            protected virtual void Dispose(bool disposing) { }

            // OnChanged 事件的实现
            public event EventHandler<ArgumentPackageChangedEventArgs> Changed;
            private void OnChanged()
            {
                if (Changed != null)
                {
                    Changed(this, new ArgumentPackageChangedEventArgs());
                }
            }
        }

        public class ArgumentPackageDataSourceFactory : DataSourceFactory
        {
            public static string DataSourceId = @"917e25ef-e3c6-4094-9a5b-3f613da4f9e4"; // Keep this ID stable
            public override IDataSource GetDataSource() { return new StructuredArchiveDataSource(DataSourceId, new[] { typeof(Arguments) }); }
        }
        #endregion

        public class Generator : SeismicAttributeGenerator
        {
            // *********************************************************************************
            // 关键修改 3: 存储 Arguments 对象以便在 Initialize 中使用
            // *********************************************************************************
            private readonly Arguments arguments;
            private readonly IGeneratorContext generatorContext;
            private float clippingMin;
            private float clippingMax;
            private bool isInitialized = false;

            private const int NUM_HISTOGRAM_BINS = 10000;

            public Generator(PercentileClipNormalization.Arguments arguments, IGeneratorContext generatorContext)
            {
                this.arguments = arguments; // 保存传入的参数对象
                this.generatorContext = generatorContext;
            }

            public override void Initialize()
            {
                if (isInitialized) return;

                try
                {
                    PetrelLogger.Info("PercentileClipNormalization: Starting pre-computation using memory-efficient histogram method...");
                    Stopwatch sw = Stopwatch.StartNew();

                    SeismicEntity inputEntity = this.generatorContext.InputSeismicData[0];
                    if (!inputEntity.IsSeismicCube) { PetrelLogger.Error("PercentileClipNormalization: Input data is not a SeismicCube."); isInitialized = true; return; }
                    SeismicCube inputCube = inputEntity.SeismicCube;
                    if (inputCube == null) { PetrelLogger.Error("PercentileClipNormalization: The SeismicCube inside the SeismicEntity is null."); isInitialized = true; return; }

                    Index3 numSamples = inputCube.NumSamplesIJK;
                    float[] traceBuffer = new float[numSamples.K];

                    float globalMin = float.MaxValue;
                    float globalMax = float.MinValue;
                    long totalSampleCount = 0;

                    PetrelLogger.Info("Histogram Pass 1: Finding global min/max...");
                    for (int i = 0; i < numSamples.I; i++)
                    {
                        for (int j = 0; j < numSamples.J; j++)
                        {
                            inputCube.GetTraceData(i, j, traceBuffer);
                            for (int k = 0; k < numSamples.K; k++)
                            {
                                float value = traceBuffer[k];
                                if (!float.IsNaN(value))
                                {
                                    if (value < globalMin) globalMin = value;
                                    if (value > globalMax) globalMax = value;
                                    totalSampleCount++;
                                }
                            }
                        }
                    }

                    if (totalSampleCount == 0)
                    {
                        PetrelLogger.Info("PercentileClipNormalization WARNING: No valid data found.");
                        clippingMin = 0; clippingMax = 1; isInitialized = true; return;
                    }
                    PetrelLogger.Info($"Histogram Pass 1 Complete. Min={globalMin}, Max={globalMax}, Total Samples={totalSampleCount}");

                    float range = globalMax - globalMin;
                    if (range < 1e-9)
                    {
                        PetrelLogger.Info("PercentileClipNormalization WARNING: All data points are constant.");
                        clippingMin = globalMin; clippingMax = globalMax; isInitialized = true; return;
                    }

                    long[] histogramBins = new long[NUM_HISTOGRAM_BINS];
                    PetrelLogger.Info("Histogram Pass 2: Populating histogram...");
                    for (int i = 0; i < numSamples.I; i++)
                    {
                        for (int j = 0; j < numSamples.J; j++)
                        {
                            inputCube.GetTraceData(i, j, traceBuffer);
                            for (int k = 0; k < numSamples.K; k++)
                            {
                                float value = traceBuffer[k];
                                if (!float.IsNaN(value))
                                {
                                    int binIndex = (int)(((value - globalMin) / range) * (NUM_HISTOGRAM_BINS - 1));
                                    binIndex = Math.Max(0, Math.Min(NUM_HISTOGRAM_BINS - 1, binIndex));
                                    histogramBins[binIndex]++;
                                }
                            }
                        }
                    }
                    PetrelLogger.Info("Histogram Pass 2 Complete.");

                    // *********************************************************************************
                    // 关键修改 4: 使用参数替换硬编码的值
                    // *********************************************************************************
                    double lowerPercentile = this.arguments.LowerPercentile / 100.0;
                    double upperPercentile = this.arguments.UpperPercentile / 100.0;

                    this.clippingMin = GetValueFromHistogram(histogramBins, totalSampleCount, lowerPercentile, globalMin, range);
                    this.clippingMax = GetValueFromHistogram(histogramBins, totalSampleCount, upperPercentile, globalMin, range);

                    sw.Stop();
                    PetrelLogger.Info($"PercentileClipNormalization: Pre-computation finished in {sw.Elapsed.TotalSeconds:F2}s. Clipping Range: [{this.clippingMin}, {this.clippingMax}]");
                }
                catch (Exception ex)
                {
                    PetrelLogger.Error("PercentileClipNormalization: A critical error occurred during initialization.", ex);
                    clippingMin = 0;
                    clippingMax = 1;
                }
                finally
                {
                    isInitialized = true;
                }
            }

            private float GetValueFromHistogram(long[] bins, long totalCount, double percentile, float minVal, float range)
            {
                long targetCount = (long)(totalCount * percentile);
                long currentCount = 0;

                for (int i = 0; i < bins.Length; i++)
                {
                    currentCount += bins[i];
                    if (currentCount >= targetCount)
                    {
                        return minVal + ((float)i / (bins.Length - 1)) * range;
                    }
                }
                return minVal + range;
            }

            public override void Calculate(ISubCube[] input, ISubCube[] output)
            {
                if (!isInitialized)
                {
                    Initialize();
                }

                ISubCube inCube = input[0];
                ISubCube outCube = output[0];

                float range = this.clippingMax - this.clippingMin;

                if (Math.Abs(range) < 1e-9)
                {
                    Index3 minFill = outCube.MinIJK;
                    Index3 maxFill = outCube.MaxIJK;
                    for (int k = minFill.K; k <= maxFill.K; k++)
                        for (int j = minFill.J; j <= maxFill.J; j++)
                            for (int i = minFill.I; i <= maxFill.I; i++)
                            {
                                outCube[new Index3(i, j, k)] = 0.0f;
                            }
                    return;
                }

                Index3 min = outCube.MinIJK;
                Index3 max = outCube.MaxIJK;

                for (int k = min.K; k <= max.K; k++)
                    for (int j = min.J; j <= max.J; j++)
                        for (int i = min.I; i <= max.I; i++)
                        {
                            Index3 idx = new Index3(i, j, k);
                            float value = inCube[idx];

                            if (float.IsNaN(value))
                            {
                                outCube[idx] = float.NaN;
                                continue;
                            }

                            float clippedValue = Math.Max(this.clippingMin, Math.Min(value, this.clippingMax));
                            float normalizedValue = (clippedValue - this.clippingMin) / range;
                            outCube[idx] = normalizedValue;
                        }
            }
        }
    }
}
```

`ocean_plugin/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ocean_plugin")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ocean_plugin")]
[assembly: AssemblyCopyright("Copyright ©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5d1c9130-ee3a-44d1-9e2d-c3911e097b5a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ocean_plugin/StructureTensor.cs`:

```cs
using System;
using System.Collections.Generic;

using Slb.Ocean.Core;
using Slb.Ocean.Basics;
using Slb.Ocean.Petrel;
using Slb.Ocean.Petrel.Data;
using Slb.Ocean.Petrel.Data.Persistence;
using Slb.Ocean.Petrel.DomainObject;
using Slb.Ocean.Petrel.Seismic;
using Slb.Ocean.Petrel.DomainObject.Seismic;
using Slb.Ocean.Petrel.Workflow;
using Slb.Ocean.Petrel.UI;

namespace ocean_plugin
{
    class StructureTensor : SeismicAttribute<StructureTensor.Arguments>, IDescriptionSource
    {
        private string[] outputNames = {
                "structure tensor"
                };


        #region Overrides from SeismicAttribute

        protected override Arguments CreateArgumentPackageCore(IDataSourceManager manager)
        {
            Arguments argPack = new Arguments();

            StructuredArchiveDataSource dataSource = manager.GetSource(ArgumentPackageDataSourceFactory.DataSourceId) as StructuredArchiveDataSource;

            if (dataSource != null)
            {
                argPack.Droid = dataSource.GenerateDroid();
                dataSource.AddItem(argPack.Droid, argPack);
            }

            return argPack;
        }


        public override void CopyArgumentPackage(StructureTensor.Arguments fromArgumentPackage, StructureTensor.Arguments toArgumentPackage)
        {
            if (fromArgumentPackage != null && toArgumentPackage != null)
            {
                toArgumentPackage.CopyFrom(fromArgumentPackage);
            }
        }

        public override bool CompareArgumentPackage(StructureTensor.Arguments firstArgumentPackage, StructureTensor.Arguments secondArgumentPackage)
        {
            if (firstArgumentPackage != null && secondArgumentPackage != null)
            {
                return firstArgumentPackage.EqualsTo(secondArgumentPackage);
            }

            return false;
        }

        public override SeismicAttributeGenerator CreateAttributeGenerator(StructureTensor.Arguments argumentPackage, IGeneratorContext context)
        {
            return new StructureTensor.Generator(argumentPackage, context);
        }

        public override bool Validate(StructureTensor.Arguments argumentPackage, IGeneratorContext context, out string errorMessage)
        {
            errorMessage = "N/A";

            // TODO: Please implement the validation logic for the argumentPackage.
            // return true, when the given argumentPackage is valid.
            // return false, and fill the errorMessage when the given argumentPackage is not valid.

            return true;
        }

        public override SeismicAttributeInfo CreateSeismicAttributeInfo(StructureTensor.Arguments argumentPackage, IGeneratorContext context)
        {

            IList<Slb.Ocean.Petrel.DomainObject.Template> templates = new List<Slb.Ocean.Petrel.DomainObject.Template>();
            IList<Range1<float>> ranges = new List<Range1<float>>();

            templates.Add(PetrelProject.WellKnownTemplates.SeismicColorGroup.SeismicDipAngle);

            ranges.Add(new Range1<float>(0, 100000000));

            return new SeismicAttributeInfo(
                templates,
                ranges,
                new Index3(5, 5, 5),
                BorderProcessingMethod.Repeat);

        }

        /// <summary>
        /// Gets the category of the attribute
        /// </summary>
        public override string CategoryName
        {
            get { return WellKnownAttributeCategory.Structural; }
        }

        /// <summary>
        /// Gets the number of the expected input cubes
        /// </summary>
        public override int InputCount
        {
            get { return 1; }
        }

        public override int OutputCount
        {
            get { return 1; }
        }

        protected override IEnumerable<string> GetInputLabels(StructureTensor.Arguments argumentPackage, IGeneratorContext context)
        {
            yield return "Input";
        }

        protected override IEnumerable<string> GetOutputLabels(StructureTensor.Arguments argumentPackage, IGeneratorContext context)
        {
            yield return "Output";
        }


        #endregion

        #region Attribute Description related members

        public IDescription Description
        {
            get { return new AttributeDescription(); }
        }

        private class AttributeDescription : IDescription
        {
            #region IDescription Members

            /// <summary>
            /// Gets the name of the attribute
            /// </summary>
            public string Name
            {
                get { return "Structural tensor"; }
            }

            /// <summary>
            /// Gets the description of the attribute
            /// </summary>
            public string Description
            {
                get { return "structural tensor"; }
            }

            /// <summary>
            /// Gets the short description of the attribute
            /// Currently it is not in use.
            /// </summary>
            public string ShortDescription
            {
                get { return string.Empty; }
            }

            #endregion
        }

        #endregion

        /// <summary>
        /// This class contains the arguments of the attribute, if it has any.
        /// </summary>
        [Archivable(FromRelease = "2020.1")]
        public class Arguments : Slb.Ocean.Petrel.Workflow.DescribedArgumentsByReflection, IIdentifiable, IDisposable, Slb.Ocean.Petrel.Seismic.INotifyingOnChanged
        {
            public Arguments() { }

            [Archived(Name = "Droid")]
            private Droid droid;
            public Droid Droid
            {
                get { return droid; }
                set { droid = value; }
            }


            public void CopyFrom(Arguments another)
            {
                // TODO: implement the argument copying
                if (another == null) throw new ArgumentNullException(nameof(another));
            }

            public bool EqualsTo(Arguments another)
            {
                // TODO: implement the argument comparing.
                // return true if the arguments are considered equal,
                // return false if they are considered not equal.

                if (another == null) return false;
                return true;
            }
            #region IDisposable Members

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    // TODO: free managed resources
                }

                // TODO: free unmanaged resources
            }

            #endregion

            #region INotifyingOnChanged Members

            public event EventHandler<ArgumentPackageChangedEventArgs> Changed;

            private void OnChanged()
            {
                if (Changed != null)
                    Changed(this, new ArgumentPackageChangedEventArgs());
            }

            #endregion

        }

        public class ArgumentPackageDataSourceFactory : DataSourceFactory
        {
            public static string DataSourceId = @"0fe46afa-5dee-4f86-8a10-8bf8c924550f";
            public override IDataSource GetDataSource()
            {
                return new StructuredArchiveDataSource(DataSourceId, new[] { typeof(Arguments) });
            }
        }


        public class Generator : SeismicAttributeGenerator
        {
            /// <summary>
            /// Argument package
            /// </summary>
            private StructureTensor.Arguments arguments;

            /// <summary>
            /// Parameterized constructor to set argument package and generator context
            /// </summary>
            /// <param name="arguments">Argument package</param>
            /// <param name="context">Generator context</param>
            /// 
            public Generator(StructureTensor.Arguments arguments, IGeneratorContext context)
            {
                this.arguments = arguments;
                // Context 被框架注入到基类，无需手动保存或传递
            }

            #region Overrides from SeismicAttributeGenerator

            public override void Initialize()
            {
                // TODO: add any initialization logic here
            }

            /// <summary>
            /// This method does the actual work of the attribute.
            /// </summary>
            /// <param name="input">array of the input subcubes</param>
            /// <param name="output">the result cube</param>
            public override void Calculate(ISubCube[] input, ISubCube[] output)
            {
                // 1) 获取输入和输出子块
                ISubCube inCube = input[0];
                ISubCube outLam1 = output[0];

                // 2) 遍历“输出”子块有效区域
                Index3 min = outLam1.MinIJK;
                Index3 max = outLam1.MaxIJK;

                for (int k = min.K; k <= max.K; k++)
                    for (int j = min.J; j <= max.J; j++)
                        for (int i = min.I; i <= max.I; i++)
                        {
                            // 3.1) 中心差分梯度（假设 CreateSeismicAttributeInfo 已设置 OperatorSize = 3×3×3）
                            float gx = (inCube[new Index3(i + 1, j, k)]
                                      - inCube[new Index3(i - 1, j, k)]) * 0.5f;
                            float gy = (inCube[new Index3(i, j + 1, k)]
                                      - inCube[new Index3(i, j - 1, k)]) * 0.5f;
                            float gz = (inCube[new Index3(i, j, k + 1)]
                                      - inCube[new Index3(i, j, k - 1)]) * 0.5f;

                            // 3.2) 直接构造瞬时结构张量分量
                            double Txx = gx * gx;
                            double Tyy = gy * gy;
                            double Tzz = gz * gz;
                            double Txy = gx * gy;
                            double Txz = gx * gz;
                            double Tyz = gy * gz;

                            // 3.3) 特征值分解
                            ComputeEigenvaluesSymmetric3x3(
                                Txx, Txy, Txz,
                                      Tyy, Tyz,
                                            Tzz,
                                out double l1, out double l2, out double l3);

                            // 3.4) 写回
                            var idx = new Index3(i, j, k);
                            outLam1[idx] = (float)l1;
                        }
            }



            #endregion
        }
        /// <summary>
        /// Analytic eigen-decomposition for symmetric 3×3 matrix:
        /// [ a00 a01 a02 ]
        /// [ a01 a11 a12 ]
        /// [ a02 a12 a22 ]
        /// </summary>
        private static void ComputeEigenvaluesSymmetric3x3(
                double a00, double a01, double a02,
                double a11, double a12,
                double a22,
                out double w0, out double w1, out double w2)
        {
            // 平移到零均值
            double m = (a00 + a11 + a22) / 3.0;
            double b00 = a00 - m, b11 = a11 - m, b22 = a22 - m;
            double b01 = a01, b02 = a02, b12 = a12;

            double p = (b00 * b00 + b11 * b11 + b22 * b22
                      + 2 * (b01 * b01 + b02 * b02 + b12 * b12)) / 6.0;
            double detB = b00 * (b11 * b22 - b12 * b12)
                        - b01 * (b01 * b22 - b12 * b02)
                        + b02 * (b01 * b12 - b11 * b02);
            double q = detB / 2.0;

            // 计算角度
            double phi = Math.Acos(Math.Max(-1, Math.Min(1, q / Math.Sqrt(p * p * p)))) / 3.0;

            // 重构特征值
            w0 = m + 2.0 * Math.Sqrt(p) * Math.Cos(phi);
            w1 = m + 2.0 * Math.Sqrt(p) * Math.Cos(phi + 2.0 * Math.PI / 3.0);
            w2 = 3.0 * m - w0 - w1;

            // 降序排序
            if (w0 < w1) { var t = w0; w0 = w1; w1 = t; }
            if (w1 < w2) { var t = w1; w1 = w2; w2 = t; }
            if (w0 < w1) { var t = w0; w0 = w1; w1 = t; }
        }
    }
}

```

`ocean_plugin/ocean_plugin.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemDefinitionGroup>
    <Reference>
      <Private>False</Private>
    </Reference>
  </ItemDefinitionGroup>
  <PropertyGroup>
    <!--ProjectType:Plugin-->
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>9.0.30729</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ocean_plugin</RootNamespace>
    <AssemblyName>ocean_plugin</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Slb.Ocean.Data, Version=1.0.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Configuration, Version=20.4.0.0, Culture=neutral, PublicKeyToken=d42cec326f61051f, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Data.Persistence, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Seismic, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Well, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Deployment" />
    <Reference Include="Slb.Ocean.Core">
      <Name>Slb.Ocean.Core</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\slb.ocean.core.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Petrel">
      <Name>Slb.Ocean.Petrel</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\slb.ocean.petrel.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Basics">
      <Name>Slb.Ocean.Basics</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\Slb.Ocean.Basics.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Geometry">
      <Name>Slb.Ocean.Geometry</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\Slb.Ocean.Geometry.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ModuleAttribute.cs" />
    <Compile Include="MultiAttributeFusion.cs" />
    <Compile Include="Plugin.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="PercentileClipNormalization.cs" />
    <Compile Include="StructureTensor.cs" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>del "$(ProjectDir)\plugin.xml"
"%25Ocean2020Home%25\PluginPackager.exe" /g "$(TargetPath)" "$(ProjectDir)\plugin.xml" "%25OCEAN2020HOME_x64%25\petrel.exe"
"%25Ocean2020Home%25\PluginPackager.exe" /m "$(ProjectDir)\plugin.xml" "%25OCEAN2020HOME_x64%25\petrel.exe" "$(TargetDir)"
</PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
		Other similar extension points exist, see Microsoft.Common.targets.
	<Target Name="BeforeBuild">
	</Target>
	<Target Name="AfterBuild">
	</Target>
	-->
</Project>
```

`ocean_plugin/ocean_plugin.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.36227.6
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ocean_plugin", "ocean_plugin.csproj", "{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FCEA0C72-1B2D-42D5-BA06-CAFE2E0A3173}
	EndGlobalSection
EndGlobal

```

`ocean_plugin/plugin.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<InstalledPlugins xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Plugin>
    <Name>Plugin</Name>
    <Contact>1968476645@qq.com</Contact>
    <PluginTypeName>ocean_plugin.Plugin, ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</PluginTypeName>
    <PluginUri>http://www.pluginuri.info/</PluginUri>
    <PluginId>://ocean_plugin.Plugin/1.0.0.0</PluginId>
    <Trust PublicKeyToken="">Default</Trust>
    <ReleaseDate>2025-08-09</ReleaseDate>
    <Author>Qiao</Author>
    <AppVersion>2020.1</AppVersion>
    <Modules>
      <Module TypeName="ocean_plugin.ModuleAttribute, ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />
    </Modules>
    <Assemblies>
      <Assembly Name="ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />
    </Assemblies>
    <assemblyBinding />
    <StartMode>Startup</StartMode>
    <StartupAction>None</StartupAction>
  </Plugin>
</InstalledPlugins>
```

`ocean_plugin/prompt.txt`:

```txt
Project Path: ocean_plugin

Source Tree:

```txt
ocean_plugin
├── ModuleAttribute.cs
├── Plugin.cs
├── Properties
│   └── AssemblyInfo.cs
├── RobustNormalization.cs
├── StructureTensor.cs
├── ocean_plugin.csproj
├── ocean_plugin.sln
└── plugin.xml

```

`ocean_plugin/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ocean_plugin")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ocean_plugin")]
[assembly: AssemblyCopyright("Copyright ©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5d1c9130-ee3a-44d1-9e2d-c3911e097b5a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`ocean_plugin/RobustNormalization.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using Slb.Ocean.Core;
using Slb.Ocean.Basics;
using Slb.Ocean.Petrel;
using Slb.Ocean.Petrel.Data;
using Slb.Ocean.Petrel.Data.Persistence;
using Slb.Ocean.Petrel.DomainObject;
using Slb.Ocean.Petrel.Seismic;
using Slb.Ocean.Petrel.DomainObject.Seismic;
using Slb.Ocean.Petrel.Workflow;
using Slb.Ocean.Petrel.UI;

namespace ocean_plugin {
    class RobustNormalization : SeismicAttribute<RobustNormalization.Arguments>, IDescriptionSource {
        #region Boilerplate Code (无需修改)
        protected override Arguments CreateArgumentPackageCore(IDataSourceManager manager) {
            Arguments argPack = new Arguments();
            StructuredArchiveDataSource dataSource = manager.GetSource(ArgumentPackageDataSourceFactory.DataSourceId) as StructuredArchiveDataSource;
            if (dataSource != null) { argPack.Droid = dataSource.GenerateDroid(); dataSource.AddItem(argPack.Droid, argPack); }
            return argPack;
        }
        public override void CopyArgumentPackage(RobustNormalization.Arguments fromArgumentPackage, RobustNormalization.Arguments toArgumentPackage) { if (fromArgumentPackage != null && toArgumentPackage != null) { toArgumentPackage.CopyFrom(fromArgumentPackage); } }
        public override bool CompareArgumentPackage(RobustNormalization.Arguments firstArgumentPackage, RobustNormalization.Arguments secondArgumentPackage) { if (firstArgumentPackage != null && secondArgumentPackage != null) { return firstArgumentPackage.EqualsTo(secondArgumentPackage); } return false; }
        public override SeismicAttributeGenerator CreateAttributeGenerator(RobustNormalization.Arguments argumentPackage, IGeneratorContext context) {
            return new RobustNormalization.Generator(argumentPackage, context);
        }
        public override bool Validate(RobustNormalization.Arguments argumentPackage, IGeneratorContext context, out string errorMessage) { errorMessage = "N/A"; return true; }
        public override SeismicAttributeInfo CreateSeismicAttributeInfo(RobustNormalization.Arguments argumentPackage, IGeneratorContext context) {
            IList<Template> templates = new List<Template>();
            IList<Range1<float>> ranges = new List<Range1<float>>();
            templates.Add(PetrelProject.WellKnownTemplates.SeismicColorGroup.SeismicDefault);
            ranges.Add(new Range1<float>(-3f, 3f));
            return new SeismicAttributeInfo(templates, ranges, new Index3(1, 1, 1), BorderProcessingMethod.Repeat);
        }
        public override string CategoryName { get { return WellKnownAttributeCategory.Basic; } }
        public override int InputCount { get { return 1; } }
        public override int OutputCount { get { return 1; } }
        protected override IEnumerable<string> GetInputLabels(RobustNormalization.Arguments argumentPackage, IGeneratorContext context) { yield return "Input"; }
        protected override IEnumerable<string> GetOutputLabels(RobustNormalization.Arguments argumentPackage, IGeneratorContext context) { yield return "Output"; }
        #endregion

        #region Attribute Description & Arguments (无需修改)
        public IDescription Description { get { return new AttributeDescription(); } }
        private class AttributeDescription : IDescription {
            public string Name { get { return "Robust Normalization"; } }
            public string Description { get { return "对输入数据进行鲁棒归一化 (value - median) / IQR"; } }
            public string ShortDescription { get { return string.Empty; } }
        }

        [Archivable(FromRelease = "2020.1")]
        public class Arguments : Slb.Ocean.Petrel.Workflow.DescribedArgumentsByReflection, IIdentifiable, IDisposable, Slb.Ocean.Petrel.Seismic.INotifyingOnChanged {
            public Arguments() { }
            [Archived(Name = "Droid")] private Droid droid;
            public Droid Droid { get { return droid; } set { droid = value; } }
            public void CopyFrom(Arguments another) { }
            public bool EqualsTo(Arguments another) { return true; }
            public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
            protected virtual void Dispose(bool disposing) { }
            public event EventHandler<ArgumentPackageChangedEventArgs> Changed;
        }

        public class ArgumentPackageDataSourceFactory : DataSourceFactory {
            public static string DataSourceId = @"917e25ef-e3c6-4094-9a5b-3f613da4f9e4";
            public override IDataSource GetDataSource() { return new StructuredArchiveDataSource(DataSourceId, new[] { typeof(Arguments) }); }
        }
        #endregion

        public class Generator : SeismicAttributeGenerator {
            private IGeneratorContext generatorContext;
            private float globalMedian;
            private float globalIqr;
            private bool isInitialized = false;

            public Generator(RobustNormalization.Arguments arguments, IGeneratorContext generatorContext) {
                this.generatorContext = generatorContext;
            }

            public override void Initialize() {
                if (isInitialized) return;

                try {
                    PetrelLogger.Info("RobustNormalization: Starting pre-computation of global statistics...");
                    Stopwatch sw = Stopwatch.StartNew();

                    if (this.generatorContext.InputSeismicData == null || this.generatorContext.InputSeismicData.Count == 0) {
                        PetrelLogger.Error("RobustNormalization: No input seismic data found in the context.");
                        isInitialized = true;
                        return;
                    }

                    // **权威解决方案: 从SeismicEntity包装器中获取SeismicCube**
                    SeismicEntity inputEntity = this.generatorContext.InputSeismicData[0];

                    if (!inputEntity.IsSeismicCube) {
                        PetrelLogger.Error("RobustNormalization: Input data is not a SeismicCube.");
                        isInitialized = true;
                        return;
                    }

                    // 打开包装器，获取真正的SeismicCube对象
                    SeismicCube inputCube = inputEntity.SeismicCube;

                    if (inputCube == null) {
                        PetrelLogger.Error("RobustNormalization: The SeismicCube inside the SeismicEntity is null.");
                        isInitialized = true;
                        return;
                    }

                    Index3 numSamples = inputCube.NumSamplesIJK;
                    List<float> allValues = new List<float>();
                    float[] traceBuffer = new float[numSamples.K];

                    for (int i = 0; i < numSamples.I; i++)
                        for (int j = 0; j < numSamples.J; j++) {
                            inputCube.GetTraceData(i, j, traceBuffer);
                            for (int k = 0; k < numSamples.K; k++) {
                                float value = traceBuffer[k];
                                if (!float.IsNaN(value)) {
                                    allValues.Add(value);
                                }
                            }
                        }

                    if (allValues.Count == 0) {
                        PetrelLogger.Info("RobustNormalization WARNING: No valid data found in the input cube.");
                        globalMedian = 0;
                        globalIqr = 1;
                        isInitialized = true;
                        return;
                    }

                    allValues.Sort();

                    float q1 = GetPercentile(allValues, 0.25);
                    this.globalMedian = GetPercentile(allValues, 0.50);
                    float q3 = GetPercentile(allValues, 0.75);
                    this.globalIqr = q3 - q1;

                    if (Math.Abs(this.globalIqr) < 1e-9) {
                        this.globalIqr = 1.0f;
                        PetrelLogger.Info("RobustNormalization WARNING: IQR is near zero.");
                    }

                    sw.Stop();
                    PetrelLogger.Info($"RobustNormalization: Pre-computation finished in {sw.Elapsed.TotalSeconds:F2}s. Median = {globalMedian}, IQR = {globalIqr}");
                }
                catch (Exception ex) {
                    PetrelLogger.Error("RobustNormalization: An unexpected error occurred during initialization.", ex);
                    globalMedian = 0;
                    globalIqr = 1;
                }
                finally {
                    isInitialized = true;
                }
            }

            public override void Calculate(ISubCube[] input, ISubCube[] output) {
                if (!isInitialized) {
                    Initialize();
                }

                ISubCube inCube = input[0];
                ISubCube outCube = output[0];

                Index3 min = outCube.MinIJK;
                Index3 max = outCube.MaxIJK;

                for (int k = min.K; k <= max.K; k++)
                    for (int j = min.J; j <= max.J; j++)
                        for (int i = min.I; i <= max.I; i++) {
                            Index3 idx = new Index3(i, j, k);
                            float value = inCube[idx];

                            if (float.IsNaN(value)) {
                                outCube[idx] = float.NaN;
                                continue;
                            }

                            float normalizedValue = (value - this.globalMedian) / this.globalIqr;
                            outCube[idx] = normalizedValue;
                        }
            }

            private float GetPercentile(List<float> sortedSequence, double percentile) {
                int n = sortedSequence.Count;
                if (n == 0) return 0;
                if (n == 1) return sortedSequence[0];
                double index = percentile * (n - 1);
                int lower = (int)Math.Floor(index);
                int upper = (int)Math.Ceiling(index);
                if (lower == upper) { return sortedSequence[lower]; }
                double fraction = index - lower;
                return (float)(sortedSequence[lower] * (1.0 - fraction) + sortedSequence[upper] * fraction);
            }
        }
    }
}
```

`ocean_plugin/StructureTensor.cs`:

```cs
using System;
using System.Collections.Generic;

using Slb.Ocean.Core;
using Slb.Ocean.Basics;
using Slb.Ocean.Petrel;
using Slb.Ocean.Petrel.Data;
using Slb.Ocean.Petrel.Data.Persistence;
using Slb.Ocean.Petrel.DomainObject;
using Slb.Ocean.Petrel.Seismic;
using Slb.Ocean.Petrel.DomainObject.Seismic;
using Slb.Ocean.Petrel.Workflow;
using Slb.Ocean.Petrel.UI;

namespace ocean_plugin {
    class StructureTensor : SeismicAttribute<StructureTensor.Arguments>, IDescriptionSource {
        private string[] outputNames = {
                "structure tensor"
                };


        #region Overrides from SeismicAttribute

        protected override Arguments CreateArgumentPackageCore(IDataSourceManager manager) {
            Arguments argPack = new Arguments();

            StructuredArchiveDataSource dataSource = manager.GetSource(ArgumentPackageDataSourceFactory.DataSourceId) as StructuredArchiveDataSource;

            if (dataSource != null) {
                argPack.Droid = dataSource.GenerateDroid();
                dataSource.AddItem(argPack.Droid, argPack);
            }

            return argPack;
        }


        public override void CopyArgumentPackage(StructureTensor.Arguments fromArgumentPackage, StructureTensor.Arguments toArgumentPackage) {
            if (fromArgumentPackage != null && toArgumentPackage != null) {
                toArgumentPackage.CopyFrom(fromArgumentPackage);
            }
        }

        public override bool CompareArgumentPackage(StructureTensor.Arguments firstArgumentPackage, StructureTensor.Arguments secondArgumentPackage) {
            if (firstArgumentPackage != null && secondArgumentPackage != null) {
                return firstArgumentPackage.EqualsTo(secondArgumentPackage);
            }

            return false;
        }

        public override SeismicAttributeGenerator CreateAttributeGenerator(StructureTensor.Arguments argumentPackage, IGeneratorContext context) {
            return new StructureTensor.Generator(argumentPackage, context);
        }

        public override bool Validate(StructureTensor.Arguments argumentPackage, IGeneratorContext context, out string errorMessage) {
            errorMessage = "N/A";

            // TODO: Please implement the validation logic for the argumentPackage.
            // return true, when the given argumentPackage is valid.
            // return false, and fill the errorMessage when the given argumentPackage is not valid.

            return true;
        }

        public override SeismicAttributeInfo CreateSeismicAttributeInfo(StructureTensor.Arguments argumentPackage, IGeneratorContext context) {

            IList<Slb.Ocean.Petrel.DomainObject.Template> templates = new List<Slb.Ocean.Petrel.DomainObject.Template>();
            IList<Range1<float>> ranges = new List<Range1<float>>();

            templates.Add(PetrelProject.WellKnownTemplates.SeismicColorGroup.SeismicDipAngle);

            ranges.Add(new Range1<float>(0, 100000000));

            return new SeismicAttributeInfo(
                templates,
                ranges,
                new Index3(5, 5, 5),
                BorderProcessingMethod.Repeat);

        }

        /// <summary>
        /// Gets the category of the attribute
        /// </summary>
        public override string CategoryName {
            get { return WellKnownAttributeCategory.Structural; }
        }

        /// <summary>
        /// Gets the number of the expected input cubes
        /// </summary>
        public override int InputCount {
            get { return 1; }
        }

        public override int OutputCount {
            get { return 1; }
        }

        protected override IEnumerable<string> GetInputLabels(StructureTensor.Arguments argumentPackage, IGeneratorContext context) {
            yield return "Input";
        }

        protected override IEnumerable<string> GetOutputLabels(StructureTensor.Arguments argumentPackage, IGeneratorContext context) {
            yield return "Output";
        }


        #endregion

        #region Attribute Description related members

        public IDescription Description {
            get { return new AttributeDescription(); }
        }

        private class AttributeDescription : IDescription {
            #region IDescription Members

            /// <summary>
            /// Gets the name of the attribute
            /// </summary>
            public string Name {
                get { return "Structural tensor"; }
            }

            /// <summary>
            /// Gets the description of the attribute
            /// </summary>
            public string Description {
                get { return "structural tensor"; }
            }

            /// <summary>
            /// Gets the short description of the attribute
            /// Currently it is not in use.
            /// </summary>
            public string ShortDescription {
                get { return string.Empty; }
            }

            #endregion
        }

        #endregion

        /// <summary>
        /// This class contains the arguments of the attribute, if it has any.
        /// </summary>
        [Archivable(FromRelease = "2020.1")]
        public class Arguments : Slb.Ocean.Petrel.Workflow.DescribedArgumentsByReflection, IIdentifiable, IDisposable, Slb.Ocean.Petrel.Seismic.INotifyingOnChanged {
            public Arguments() { }

            [Archived(Name = "Droid")]
            private Droid droid;
            public Droid Droid {
                get { return droid; }
                set { droid = value; }
            }


            public void CopyFrom(Arguments another) {
                // TODO: implement the argument copying
                if (another == null) throw new ArgumentNullException(nameof(another));
            }

            public bool EqualsTo(Arguments another) {
                // TODO: implement the argument comparing.
                // return true if the arguments are considered equal,
                // return false if they are considered not equal.

                if (another == null) return false;
                return true;
            }
            #region IDisposable Members

            public void Dispose() {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing) {
                if (disposing) {
                    // TODO: free managed resources
                }

                // TODO: free unmanaged resources
            }

            #endregion

            #region INotifyingOnChanged Members

            public event EventHandler<ArgumentPackageChangedEventArgs> Changed;

            private void OnChanged() {
                if (Changed != null)
                    Changed(this, new ArgumentPackageChangedEventArgs());
            }

            #endregion

        }

        public class ArgumentPackageDataSourceFactory : DataSourceFactory {
            public static string DataSourceId = @"0fe46afa-5dee-4f86-8a10-8bf8c924550f";
            public override IDataSource GetDataSource() {
                return new StructuredArchiveDataSource(DataSourceId, new[] { typeof(Arguments) });
            }
        }


        public class Generator : SeismicAttributeGenerator {
            /// <summary>
            /// Argument package
            /// </summary>
            private StructureTensor.Arguments arguments;

            /// <summary>
            /// Parameterized constructor to set argument package and generator context
            /// </summary>
            /// <param name="arguments">Argument package</param>
            /// <param name="context">Generator context</param>
            /// 
            public Generator(StructureTensor.Arguments arguments, IGeneratorContext context) {
                this.arguments = arguments;
                // Context 被框架注入到基类，无需手动保存或传递
            }

            #region Overrides from SeismicAttributeGenerator

            public override void Initialize() {
                // TODO: add any initialization logic here
            }

            /// <summary>
            /// This method does the actual work of the attribute.
            /// </summary>
            /// <param name="input">array of the input subcubes</param>
            /// <param name="output">the result cube</param>
            public override void Calculate(ISubCube[] input, ISubCube[] output) {
                // 1) 获取输入和输出子块
                ISubCube inCube = input[0];
                ISubCube outLam1 = output[0];

                // 2) 遍历“输出”子块有效区域
                Index3 min = outLam1.MinIJK;
                Index3 max = outLam1.MaxIJK;

                for (int k = min.K; k <= max.K; k++)
                    for (int j = min.J; j <= max.J; j++)
                        for (int i = min.I; i <= max.I; i++) {
                            // 3.1) 中心差分梯度（假设 CreateSeismicAttributeInfo 已设置 OperatorSize = 3×3×3）
                            float gx = (inCube[new Index3(i + 1, j, k)]
                                      - inCube[new Index3(i - 1, j, k)]) * 0.5f;
                            float gy = (inCube[new Index3(i, j + 1, k)]
                                      - inCube[new Index3(i, j - 1, k)]) * 0.5f;
                            float gz = (inCube[new Index3(i, j, k + 1)]
                                      - inCube[new Index3(i, j, k - 1)]) * 0.5f;

                            // 3.2) 直接构造瞬时结构张量分量
                            double Txx = gx * gx;
                            double Tyy = gy * gy;
                            double Tzz = gz * gz;
                            double Txy = gx * gy;
                            double Txz = gx * gz;
                            double Tyz = gy * gz;

                            // 3.3) 特征值分解
                            ComputeEigenvaluesSymmetric3x3(
                                Txx, Txy, Txz,
                                      Tyy, Tyz,
                                            Tzz,
                                out double l1, out double l2, out double l3);

                            // 3.4) 写回
                            var idx = new Index3(i, j, k);
                            outLam1[idx] = (float)l1;
                        }
            }



            #endregion
        }
        /// <summary>
        /// Analytic eigen-decomposition for symmetric 3×3 matrix:
        /// [ a00 a01 a02 ]
        /// [ a01 a11 a12 ]
        /// [ a02 a12 a22 ]
        /// </summary>
        private static void ComputeEigenvaluesSymmetric3x3(
                double a00, double a01, double a02,
                double a11, double a12,
                double a22,
                out double w0, out double w1, out double w2) {
            // 平移到零均值
            double m = (a00 + a11 + a22) / 3.0;
            double b00 = a00 - m, b11 = a11 - m, b22 = a22 - m;
            double b01 = a01, b02 = a02, b12 = a12;

            double p = (b00 * b00 + b11 * b11 + b22 * b22
                      + 2 * (b01 * b01 + b02 * b02 + b12 * b12)) / 6.0;
            double detB = b00 * (b11 * b22 - b12 * b12)
                        - b01 * (b01 * b22 - b12 * b02)
                        + b02 * (b01 * b12 - b11 * b02);
            double q = detB / 2.0;

            // 计算角度
            double phi = Math.Acos(Math.Max(-1, Math.Min(1, q / Math.Sqrt(p * p * p)))) / 3.0;

            // 重构特征值
            w0 = m + 2.0 * Math.Sqrt(p) * Math.Cos(phi);
            w1 = m + 2.0 * Math.Sqrt(p) * Math.Cos(phi + 2.0 * Math.PI / 3.0);
            w2 = 3.0 * m - w0 - w1;

            // 降序排序
            if (w0 < w1) { var t = w0; w0 = w1; w1 = t; }
            if (w1 < w2) { var t = w1; w1 = w2; w2 = t; }
            if (w0 < w1) { var t = w0; w0 = w1; w1 = t; }
        }
    }
}

```

`ocean_plugin/ocean_plugin.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemDefinitionGroup>
    <Reference>
      <Private>False</Private>
    </Reference>
  </ItemDefinitionGroup>
  <PropertyGroup>
    <!--ProjectType:Plugin-->
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>9.0.30729</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ocean_plugin</RootNamespace>
    <AssemblyName>ocean_plugin</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Slb.Ocean.Data, Version=1.0.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Configuration, Version=20.4.0.0, Culture=neutral, PublicKeyToken=d42cec326f61051f, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Data.Persistence, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Seismic, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="Slb.Ocean.Petrel.Well, Version=20.5.0.0, Culture=neutral, PublicKeyToken=14ef4a483ef6a64b, processorArchitecture=MSIL" />
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Deployment" />
    <Reference Include="Slb.Ocean.Core">
      <Name>Slb.Ocean.Core</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\slb.ocean.core.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Petrel">
      <Name>Slb.Ocean.Petrel</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\slb.ocean.petrel.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Basics">
      <Name>Slb.Ocean.Basics</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\Slb.Ocean.Basics.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Slb.Ocean.Geometry">
      <Name>Slb.Ocean.Geometry</Name>
      <HintPath>C:\Program Files\Schlumberger\Petrel 2020\Public\Slb.Ocean.Geometry.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ModuleAttribute.cs" />
    <Compile Include="Plugin.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="RobustNormalization.cs" />
    <Compile Include="StructureTensor.cs" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>del "$(ProjectDir)\plugin.xml"
"%25Ocean2020Home%25\PluginPackager.exe" /g "$(TargetPath)" "$(ProjectDir)\plugin.xml" "%25OCEAN2020HOME_x64%25\petrel.exe"
"%25Ocean2020Home%25\PluginPackager.exe" /m "$(ProjectDir)\plugin.xml" "%25OCEAN2020HOME_x64%25\petrel.exe" "$(TargetDir)"
</PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
		Other similar extension points exist, see Microsoft.Common.targets.
	<Target Name="BeforeBuild">
	</Target>
	<Target Name="AfterBuild">
	</Target>
	-->
</Project>
```

`ocean_plugin/ocean_plugin.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.36227.6
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ocean_plugin", "ocean_plugin.csproj", "{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7743F0BA-0382-46FA-9EA4-EEDFDE64489D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FCEA0C72-1B2D-42D5-BA06-CAFE2E0A3173}
	EndGlobalSection
EndGlobal

```

`ocean_plugin/plugin.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<InstalledPlugins xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Plugin>
    <Name>Plugin</Name>
    <Contact>1968476645@qq.com</Contact>
    <PluginTypeName>ocean_plugin.Plugin, ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</PluginTypeName>
    <PluginUri>http://www.pluginuri.info/</PluginUri>
    <PluginId>://ocean_plugin.Plugin/1.0.0.0</PluginId>
    <Trust PublicKeyToken="">Default</Trust>
    <ReleaseDate>2025-08-09</ReleaseDate>
    <Author>Qiao</Author>
    <AppVersion>2020.1</AppVersion>
    <Modules>
      <Module TypeName="ocean_plugin.ModuleAttribute, ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />
    </Modules>
    <Assemblies>
      <Assembly Name="ocean_plugin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />
    </Assemblies>
    <assemblyBinding />
    <StartMode>Startup</StartMode>
    <StartupAction>None</StartupAction>
  </Plugin>
</InstalledPlugins>
```
```